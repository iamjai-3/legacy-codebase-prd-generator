{json_str}

You are given a **Java Swing Form Backend JSON** as input.

**Task:**

Convert this Java backend specification to a complete **ASP.NET Core 9.0** backend application following the multi-layer architecture pattern.

**Technology Stack:**

- **ASP.NET Core 9.0** - Web API framework
- **Entity Framework Core** - ORM for database operations
- **PostgreSQL 16** - Database (via Npgsql provider)
- **Swagger/OpenAPI** - API documentation
- **AutoMapper Pattern** - Entity to DTO mapping (or manual mappers)

**Project Structure:**

The solution follows a clean architecture with separate projects:
- **{ProjectName}.API** - Controllers, Middleware, Program.cs
- **{ProjectName}.Business** - Services, DTOs, Mappers, Configuration
- **{ProjectName}.Data** - Entities, DbContext, Configurations (PostgreSQL via Npgsql)
- **{ProjectName}.Common** - Shared utilities and context

1. Based on the provided form JSON, suggest the suitable filenames for the .NET files that follow this structure:

```
{ProjectName}.Business/
â”œâ”€â”€ DTOs/
â”‚   â””â”€â”€ {EntityName}/
â”‚       â”œâ”€â”€ {EntityName}CreateDto.cs
â”‚       â”œâ”€â”€ {EntityName}ReadDto.cs
â”‚       â””â”€â”€ {EntityName}UpdateDto.cs
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Interfaces/
â”‚   â”‚   â””â”€â”€ I{EntityName}Service.cs
â”‚   â””â”€â”€ {EntityName}Service.cs
â”œâ”€â”€ Mappers/
â”‚   â””â”€â”€ {EntityName}Mapper.cs

{ProjectName}.API/
â”œâ”€â”€ Controllers/
â”‚   â””â”€â”€ {EntityName}Controller.cs

{ProjectName}.Data/
â”œâ”€â”€ Entities/
â”‚   â””â”€â”€ {EntityName}.cs
â”œâ”€â”€ Configurations/
â”‚   â””â”€â”€ {EntityName}Configuration.cs
```

   * Return the filenames first as a **list under a delimiter** 

2. Then, for each filename, generate its code content in the following format:

```filenames
<file content here>
```

3. Provide Documentation containing:
- Mapping between Java Swing to .NET backend
- API Endpoint Configuration Details
- Database schema mapping
- Validation rules implementation

Format Required:
===DOCUMENTATION_START===
<file content here>
===DOCUMENTATION_END===

4. Generate the swagger.json file in OpenAPI 3.0 format (Make sure your including the correct case sensitivity for api endpoints request and response):
===SWAGGER_START===
<swagger content here>
===SWAGGER_END===

**Instructions:**

### Core Principles (Must-Have):

**Code Quality:**
* Replace `{entity_name}` with the relevant entity name extracted from the JSON
* Use clean, modular, and consistent coding practices following .NET conventions
* Ensure proper dependency injection and interface-based design
* Use Entity Framework Core for database operations
* Implement async/await patterns throughout
* Follow RESTful API best practices
* Use proper C# naming conventions (PascalCase for classes/methods, camelCase for parameters)

**Input Validation & Security:**
* Use Data Annotations ([Required], [MaxLength], [Range]) in DTOs for validation
* Validate data types, required fields, and format constraints at the DTO level
* Sanitize input data to prevent security vulnerabilities
* Use parameterized queries (EF Core handles this automatically)
* Apply reasonable limits on bulk operations
* Implement proper authentication and authorization attributes when needed

**Error Handling:**
* Implement robust error handling with meaningful, user-friendly messages
* Use try-catch blocks appropriately
* Return proper HTTP status codes (200, 201, 400, 404, 500)
* Log errors using ILogger
* Handle database exceptions gracefully
* Validate required configuration on service initialization

**Database Operations:**
* Use Entity Framework Core with async operations
* Configure PostgreSQL connection via Npgsql provider in appsettings.json
* Implement proper transaction handling where needed
* Return consistent response structures across all endpoints
* Handle empty results and edge cases gracefully
* Use DTOs to separate domain models from API contracts
* Implement PagedResult<T> pattern for paginated endpoints
* Use Fluent API configurations in separate Configuration classes
* For document storage, integrate AWS S3 when needed

### Nice-to-Have Improvements:

**Enhanced Reliability:**
* Add retry logic for transient failures using Polly
* Implement comprehensive logging for debugging and monitoring
* Add request/response validation middleware
* Include performance optimizations where applicable
* Implement health checks

**Better User Experience:**
* Provide detailed error messages for different scenarios
* Include data transformation utilities
* Add support for filtering, sorting, and pagination
* Implement caching strategies using IMemoryCache
* Support for bulk operations

**API Documentation:**
* Include XML documentation comments for all public APIs
* Add Swagger/OpenAPI annotations
* Provide example request/response bodies
* Document all validation rules

**Dependencies:**

{dependencies}

**Required NuGet Packages:**
- Microsoft.AspNetCore.OpenApi
- Swashbuckle.AspNetCore
- Microsoft.EntityFrameworkCore
- Npgsql.EntityFrameworkCore.PostgreSQL
- AutoMapper.Extensions.Microsoft.DependencyInjection (optional)
- AWSSDK.S3 (for document storage, if needed)

**Common Patterns:**

* **Pagination**: Implement `/paged` endpoints that return `PagedResult<T>` with pageNumber, pageSize, totalCount, totalPages, hasPreviousPage, hasNextPage
* **Logging**: Use ILogger<T> for structured logging with LogDebug, LogInformation, LogWarning, LogError
* **Dependency Injection**: Register services in Program.cs with proper lifetimes (Scoped for DbContext and services)
* **Mappers**: Create static mapper classes to convert between Entity and DTO objects
* **Namespaces**: Use consistent namespace structure: {ProjectName}.{Layer}.{Feature}
* **Async/Await**: All database operations must be async with CancellationToken support

---

ðŸ‘‰ Example expected response structure:

```filenames
{ProjectName}.Business/DTOs/Subchapter/SubchapterCreateDto.cs
{ProjectName}.Business/DTOs/Subchapter/SubchapterReadDto.cs
{ProjectName}.Business/DTOs/Subchapter/SubchapterUpdateDto.cs
{ProjectName}.Business/Services/Interfaces/ISubchapterService.cs
{ProjectName}.Business/Services/SubchapterService.cs
{ProjectName}.Business/Mappers/SubchapterMapper.cs
{ProjectName}.API/Controllers/SubchaptersController.cs
{ProjectName}.Data/Entities/Subchapter.cs
{ProjectName}.Data/Configurations/SubchapterConfiguration.cs
```

```{ProjectName}.Business/DTOs/Subchapter/SubchapterCreateDto.cs
using System.ComponentModel.DataAnnotations;

namespace {ProjectName}.Business.DTOs.Subchapter;

public class SubchapterCreateDto
{{
    [Required(ErrorMessage = "Fleet is required")]
    [MaxLength(10, ErrorMessage = "Fleet code cannot exceed 10 characters")]
    public string Fleet {{ get; set; }} = string.Empty;

    [Required(ErrorMessage = "Chapter is required")]
    [MaxLength(3, ErrorMessage = "Chapter code cannot exceed 3 characters")]
    public string Chapter {{ get; set; }} = string.Empty;

    [Required(ErrorMessage = "Subchapter is required")]
    [MaxLength(2, ErrorMessage = "Subchapter code cannot exceed 2 characters")]
    public string Subchapter {{ get; set; }} = string.Empty;

    [MaxLength(50)]
    public string? Description {{ get; set; }}
}}
```

```{ProjectName}.Business/DTOs/Subchapter/SubchapterReadDto.cs
namespace {ProjectName}.Business.DTOs.Subchapter;

public class SubchapterReadDto
{{
    public int SubchaptersId {{ get; set; }}
    public string Fleet {{ get; set; }} = string.Empty;
    public string Chapter {{ get; set; }} = string.Empty;
    public string Subchapter {{ get; set; }} = string.Empty;
    public string? Description {{ get; set; }}
}}
```

```{ProjectName}.API/Controllers/SubchaptersController.cs
using Microsoft.AspNetCore.Mvc;
using {ProjectName}.Business.DTOs.Subchapter;
using {ProjectName}.Business.Services.Interfaces;
using {ProjectName}.Business.Common;

namespace {ProjectName}.API.Controllers;

[ApiController]
[Route("api/[controller]")]
[Produces("application/json")]
public class SubchaptersController : ControllerBase
{{
    private readonly ISubchapterService _service;
    private readonly ILogger<SubchaptersController> _logger;

    public SubchaptersController(ISubchapterService service, ILogger<SubchaptersController> logger)
    {{
        _service = service ?? throw new ArgumentNullException(nameof(service));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }}

    [HttpGet]
    [ProducesResponseType(typeof(IEnumerable<SubchapterReadDto>), StatusCodes.Status200OK)]
    public async Task<ActionResult<IEnumerable<SubchapterReadDto>>> GetAll(CancellationToken cancellationToken)
    {{
        _logger.LogDebug("Getting all subchapters");
        var items = await _service.GetAllAsync(cancellationToken);
        return Ok(items);
    }}

    [HttpGet("paged")]
    [ProducesResponseType(typeof(PagedResult<SubchapterReadDto>), StatusCodes.Status200OK)]
    public async Task<ActionResult<PagedResult<SubchapterReadDto>>> GetPaged(
        [FromQuery] int pageNumber = 1,
        [FromQuery] int pageSize = 20,
        CancellationToken cancellationToken = default)
    {{
        _logger.LogDebug("Getting paged subchapters: page={{PageNumber}}, size={{PageSize}}", pageNumber, pageSize);
        var result = await _service.GetPagedAsync(pageNumber, pageSize, cancellationToken);
        return Ok(result);
    }}

    [HttpGet("{{id}}")]
    [ProducesResponseType(typeof(SubchapterReadDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<SubchapterReadDto>> GetById(int id, CancellationToken cancellationToken)
    {{
        _logger.LogDebug("Getting subchapter by ID: {{Id}}", id);
        var item = await _service.GetByIdAsync(id, cancellationToken);
        if (item == null)
        {{
            _logger.LogWarning("Subchapter not found: ID={{Id}}", id);
            return NotFound();
        }}
        return Ok(item);
    }}

    [HttpPost]
    [ProducesResponseType(typeof(SubchapterReadDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<SubchapterReadDto>> Create(
        [FromBody] SubchapterCreateDto dto,
        CancellationToken cancellationToken)
    {{
        _logger.LogInformation("Creating subchapter");
        var item = await _service.CreateAsync(dto, cancellationToken);
        return CreatedAtAction(nameof(GetById), new {{ id = item.SubchaptersId }}, item);
    }}

    [HttpPut("{{id}}")]
    [ProducesResponseType(typeof(SubchapterReadDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<SubchapterReadDto>> Update(
        int id,
        [FromBody] SubchapterUpdateDto dto,
        CancellationToken cancellationToken)
    {{
        if (id != dto.SubchaptersId)
        {{
            return BadRequest("ID mismatch");
        }}
        _logger.LogInformation("Updating subchapter: ID={{Id}}", id);
        var item = await _service.UpdateAsync(id, dto, cancellationToken);
        return Ok(item);
    }}

    [HttpDelete("{{id}}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Delete(int id, CancellationToken cancellationToken)
    {{
        _logger.LogInformation("Deleting subchapter: ID={{Id}}", id);
        await _service.DeleteAsync(id, cancellationToken);
        return NoContent();
    }}
}}
```

===DOCUMENTATION_START===
# .NET Backend Documentation

## Overview
This .NET Web API provides backend services for {entity_name} management.

## API Endpoints
- GET /api/{entity_name} - Get all records
- GET /api/{entity_name}/{{id}} - Get by ID
- POST /api/{entity_name} - Create new record
- PUT /api/{entity_name}/{{id}} - Update record
- DELETE /api/{entity_name}/{{id}} - Delete record

## Database Schema
...
===DOCUMENTATION_END===

===SWAGGER_START===
{{
  "openapi": "3.0.0",
  "info": {{
    "title": "{entity_name} API",
    "version": "1.0.0"
  }},
  "paths": {{
    "/api/{entity_name}": {{
      "get": {{
        "summary": "Get all {entity_name} records",
        ...
      }}
    }}
  }}
}}
===SWAGGER_END===
